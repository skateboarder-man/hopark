---
layout: post
title: springMVC 패턴 spriong security_1(userService)
tags: [spring]
categories: spring
---

- Spring Security(사용자 정보 조회 서비스)

> CustomUserDetails 클래스를 구현하기 전에 사용자 정보를 조회하는 서비스를 구현하겠다.
> 보안의 시작은 정확한 사용자 정보를 가져오는 것이다. 계정 잠금 기능까지 고려한 DB 설계와 로직을 살펴보겠다.

- DDL
> 회원 정보뿐만 아니라 권한(Role)과 보안 상태(fail_cnt, lock_user)를 관리할 수 있도록 설계했다.

```
CREATE TABLE `MEMBER` (
  `member_id` int NOT NULL AUTO_INCREMENT COMMENT '회원 고유 번호',
  `user_id` varchar(50) COLLATE utf8mb4_general_ci NOT NULL COMMENT '회원 아이디',
  `password` varchar(100) COLLATE utf8mb4_general_ci NOT NULL COMMENT '회원 비밀번호',
  `name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '회원 이름',
  `email` varchar(100) COLLATE utf8mb4_general_ci NOT NULL COMMENT '회원 이메일 주소',
  `phone_number` varchar(20) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '회원 핸드폰 번호',
  `department_id` int DEFAULT NULL COMMENT '소속 부서 번호',
  `is_deleted` char(1) COLLATE utf8mb4_general_ci DEFAULT 'N' COMMENT '삭제 여부',
  `created_at` timestamp NULL DEFAULT NULL COMMENT '가입일',
  `updated_at` timestamp NULL DEFAULT NULL COMMENT '정보 수정일',
  `user_grade` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '사용자 권한',
  `fail_cnt` int DEFAULT '0' COMMENT '로그인실패횟수',
  `lock_user` char(1) COLLATE utf8mb4_general_ci DEFAULT 'N' COMMENT '사용자 락',
  PRIMARY KEY (`member_id`),
  UNIQUE KEY `user_id` (`user_id`)
) COMMENT='회원 정보를 관리';

CREATE TABLE `REFRESH_TOKENS` (
  `member_id` int NOT NULL COMMENT '회원 고유 번호',
  `refresh_token` varchar(255) COLLATE utf8mb4_general_ci NOT NULL COMMENT 'Refresh Token 고유 값',
  `expiry_date` datetime NOT NULL COMMENT '토큰 만료 일시',
  PRIMARY KEY (`refresh_token`),
  KEY `REFRESH_TOKENS_MEMBER_FK` (`member_id`),
  CONSTRAINT `REFRESH_TOKENS_MEMBER_FK` FOREIGN KEY (`member_id`) REFERENCES `MEMBER` (`member_id`)
) COMMENT='JWT Refresh Token 관리';

CREATE TABLE `TNAUTHORINFO` (
  `author_id` int NOT NULL AUTO_INCREMENT COMMENT '권한코드',
  `author_nm` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '권한명',
  `author_dc` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '권한설명',
  `author_creat_de` timestamp NOT NULL COMMENT '권한생성일',
  PRIMARY KEY (`author_id`),
  UNIQUE KEY `TNAUTHORINFO_PK` (`author_id`)
) COMMENT='권한정보 관리';

CREATE TABLE `USER_ROLE` (
  `member_id` int NOT NULL,
  `author_id` int NOT NULL,
  PRIMARY KEY (`member_id`,`author_id`),
  KEY `author_id` (`author_id`),
  CONSTRAINT `USER_ROLE_ibfk_1` FOREIGN KEY (`member_id`) REFERENCES `MEMBER` (`member_id`) ON DELETE CASCADE,
  CONSTRAINT `USER_ROLE_ibfk_2` FOREIGN KEY (`author_id`) REFERENCES `TNAUTHORINFO` (`author_id`) ON DELETE CASCADE
) COMMENT='사용자권한 관리';
```

- UserVO
> DB 데이터를 담을 바구니입니다. Security 권한 처리를 위해 roles 리스트를 포함했다.

```
package co.spring.mvc.user.service;

import java.sql.Timestamp;
import java.util.List;

import co.spring.mvc.role.service.RoleVO;
import lombok.Data;
import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

@Getter
@Setter
@ToString
@Data
public class UserVO {
	
	private int memberId;
	
	private String userId;
	
    private String password;
    
    private String confirmPassword;
	
    private String name;
	
    private String email;
    
    private String phoneNumber;
    
	private int failCnt;   // 실패 횟수
	
	private String userGrade;
	
    private int departmentId;
	
    private String isDeleted;
    
    private Timestamp createdAt;
    
    private Timestamp updatedAt;
    
    private String lockUser;
    
    private List <String> roles ;
    
    private List <RoleVO> userRoles ;

}
```


- UserService

```
package co.spring.mvc.user.service;

import java.util.Map;

public interface UserService {

	Map<String, Object> getDepartmentList() throws Exception;

	Map<String, Object> singUp(UserVO userVO) throws Exception;

	Map<String, Object> checkId(UserVO userVO) throws Exception;

}
```

- UserMapper

```
package co.spring.mvc.user.service.impl;

import java.util.List;
import java.util.Map;

import org.egovframe.rte.psl.dataaccess.mapper.Mapper;

import co.spring.mvc.user.service.UserVO;

@Mapper
public interface UserMapper {

	List<Map<String, Object>> getDepartmentList() throws Exception;

	int singUp(UserVO userVO) throws Exception;

	int IdCnt(UserVO userVO) throws Exception;

	UserVO findByUser(String username) ; // Spring Security의 계약에 따라 오직 **UsernameNotFoundException**만을 던지도록 선언

	int incrementFailureCount(String username);
	
	int getFailureCount(String username);

	int lockUserAccount(String username);

	boolean checkUserExists(String username);

	int resetFailCountAndUnlockUser(String username);

	int resetFailCount(String userId);

	List<String> findByUserRoles(String username);

}
```

- UserServerImpl
> 단순 조회가 아님. 로그인 실패 시 카운트를 올리고, 5회 초과 시 계정을 잠그는(lock_user) 보안 로직이 포함되어 있음.

```
package co.spring.mvc.user.service.impl;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.egovframe.rte.fdl.cmmn.EgovAbstractServiceImpl;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import co.spring.mvc.user.service.UserService;
import co.spring.mvc.user.service.UserVO;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class UserServiceImpl extends EgovAbstractServiceImpl implements UserService{
	
	private static final Logger LOGGER = LoggerFactory.getLogger(UserServiceImpl.class);
	private final UserMapper userDAO;
	private final PasswordEncoder passwordEncoder;
	
	@Override
	public Map<String, Object> getDepartmentList() throws Exception {
		Map<String, Object> resultMap = new HashMap<String,Object>();
		List<Map<String, Object>> dataList = new ArrayList<Map<String,Object>>();
		dataList = userDAO.getDepartmentList();
		
		if(dataList.size() < 1) {
			resultMap.put("msg","Not Found");
			resultMap.put("code","404");
			return resultMap;
		}
		
		resultMap.put("data",dataList);
		resultMap.put("code","200");
		
		return resultMap;
	}

	@Override
	public Map<String, Object> singUp(UserVO userVO) throws Exception {
		Map<String, Object> resultMap = new HashMap<String,Object>();
		String password  = userVO.getPassword();
		String confirmPassword = userVO.getConfirmPassword();
		String encodedPassword = "";
		
		if(!password .equals(confirmPassword)) {
			resultMap.put("msg","비밀번호 입력이 일치하지 않습니다.");
			resultMap.put("code","500"); 
			return resultMap;
		}
		
		int IdCnt = userDAO.IdCnt(userVO); // 아이디 중복검사
		
		if(IdCnt > 0) {
			resultMap.put("msg","같은아이디가 존재 합니다.");
			resultMap.put("code","500"); 
			return resultMap;
		}
		
		try {
			encodedPassword = passwordEncoder.encode(password);
		}catch(Exception e){
			LOGGER.debug(e.getMessage());
		}
		
		userVO.setPassword(encodedPassword);
		int checkInt = userDAO.singUp(userVO);
		
		if(checkInt < 1) { 
			resultMap.put("msg","회원가입 실패");
			resultMap.put("code","500");
			return resultMap; 
		}
		
		resultMap.put("msg","회원가입 완료.");
		resultMap.put("code","200"); 
		return resultMap;
	}

	@Override
	public Map<String, Object> checkId(UserVO userVO) throws Exception {
		Map<String, Object> resultMap = new HashMap<String,Object>();
		
		if(userVO.getUserId() =="" || userVO.getUserId() ==null) {
			resultMap.put("msg","필수값 누락되었습니다.");
			resultMap.put("code","400"); 
			return resultMap;
		}
		
		int IdCnt = userDAO.IdCnt(userVO); // 아이디 중복검사
					
		if(IdCnt > 0) {
			resultMap.put("msg","같은아이디가 존재 합니다.");
			resultMap.put("code","500"); 
			return resultMap;
		}
		resultMap.put("code","200");
		resultMap.put("msg","사용가능한 아이디 입니다.");
		return resultMap;
	}

}
```


- User_SQL.xml

```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="co.spring.mvc.user.service.impl.UserMapper">

	<resultMap id="userInfo" type="co.spring.mvc.user.service.UserVO">
		<result property="memberId" column="member_id"/>
		<result property="userId" column="user_id"/>
		<result property="password" column="password"/>
		<result property="name" column="name"/>
		<result property="email" column="email"/>
		<result property="failCnt" column="fail_cnt"/>
		<result property="isDeleted" column="is_deleted"/>
		<result property="lockUser" column="lock_user"/>
		
	</resultMap>
	
	<!-- <resultMap id="depart" type="co.spring.mvc.user.service.DepartVO">
		<result property="departmentId" column="department_id"/>
		<result property="departmentName" column="department_name"/>
	</resultMap> -->

	<select id="getDepartmentList" resultType="egovMap">
		SELECT
			*
		FROM DEPARTMENT
		WHERE 1=1
	</select>
	
	<insert id="singUp" parameterType="userVO">
		INSERT INTO MEMBER (
			user_id
			, password
		  	, name
		  	, email
		  	, department_id
		  	, is_deleted
		  	, created_at
		  	, user_grade
		  	, fail_cnt
		  	, lock_user
		)
		VALUES (
			#{userId}
			, #{password}
			, #{name}
			, #{email}
			, #{departmentId}
			, 'N'
			, NOW()
			, 'user'
			, 0
			,'N'
		)
	</insert>
	
	<select id="IdCnt" parameterType="userVO" resultType="int">
		SELECT
			COUNT(user_id)
		FROM MEMBER
		WHERE 1=1
			AND user_id = #{userId}
			AND is_deleted ='N'
	</select>
	
	<select id="findByUser" parameterType="String" resultMap="userInfo">
		SELECT
			member_id
			, user_id
			, password
			, name
			, email
			, fail_cnt
			, is_deleted
			, lock_user
		FROM MEMBER
		WHERE 1=1
			AND user_id = #{value}
			AND is_deleted ='N'
	</select>
	
	<update id="incrementFailureCount" parameterType="String">
		UPDATE MEMBER SET
			fail_cnt = fail_cnt + 1
		WHERE 1=1
			AND user_id = #{value}
			AND is_deleted ='N'
	</update>
	
	<select id="getFailureCount" parameterType="String" resultType="int">
		SELECT
			fail_cnt
		FROM MEMBER
		WHERE 1=1
			AND	user_id = #{value}
			AND is_deleted ='N'
	</select>
	
	<update id ="lockUserAccount" parameterType="String">
		UPDATE MEMBER SET
			lock_user = 'Y'
		WHERE 1=1
			AND user_id = #{value}
			AND is_deleted ='N'
	</update>
	
	<select id ="checkUserExists" parameterType="String" resultType="Boolean">
		SELECT
			COUNT(1)
		FROM MEMBER
		WHERE 1=1
			AND user_id = #{value}
			AND is_deleted ='N'
	</select>
	
	<update id ="resetFailCountAndUnlockUser" parameterType="String">
		UPDATE MEMBER SET
			fail_cnt = 0
			, lock_user = 'N'
		WHERE 1=1
			AND user_id = #{value}
			AND is_deleted ='N'
	</update>
	
	<update id="resetFailCount" parameterType="String">
		UPDATE MEMBER SET
			fail_cnt = 0
		WHERE 1=1
			AND user_id = #{value}
			AND is_deleted ='N'
	</update>
	
	<select id="findByUserRoles" parameterType="String" resultType="String">
		SELECT
	 		t.author_nm
		FROM 
			MEMBER AS m
			, USER_ROLE AS ur
			, TNAUTHORINFO AS t 
		WHERE 1=1
			AND m.user_id = #{value}
			AND m.is_deleted ='N'
			AND m.member_id = ur.member_id
			AND ur.author_id = t.author_id
	</select>
</mapper>
```

> 코드 설명 보안을 고려한 DB 및 비즈니스 로직 설계
> - Spring Security를 연동할 때 가장 중요한 것은 인증 실패에 대한 처리. 제가 구성한 로직의 핵심 포인트는 다음과 같다.
> - 계정 잠금 정책: fail_cnt 컬럼을 통해 로그인 실패 횟수를 기록하고, 5회 실패 시 lock_user = 'Y'로 업데이트하여 접근을 차단합.
> - 다중 권한 처리: findByUserRoles 쿼리를 통해 한 사용자가 여러 개의 권한(ADMIN, USER 등)을 가질 수 있도록 N:M 관계를 처리.
> - 비밀번호 암호화: UserServiceImpl의 signUp 메서드에서 PasswordEncoder를 사용하여 안전하게 해싱된 비밀번호를 저장.

사용자 조회, 로그인 실패 카운트 및(비밀번호 잘못 입력 5회시 계정 잠금 기능), 사용자 존재여부 등... 기능을 하는 서비스 로직이다. Spring Security 인증 및 보안 강화(비밀번호 5회 실패 시 계정 잠금 등)를 위한 핵심 쿼리와 서비스 로직 위주로 정리했다.






